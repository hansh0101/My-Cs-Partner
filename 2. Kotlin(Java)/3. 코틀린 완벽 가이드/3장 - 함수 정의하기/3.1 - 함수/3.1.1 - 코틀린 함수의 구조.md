# 3.1.1 - 코틀린 함수의 구조

- 반지름이 주어졌을 때 원의 넓이를 계산하는 함수를 정의해보겠다.
    
    ```kotlin
    import kotlin.math.PI
    
    fun circleArea(radius: Double): Double {
    	return PI * radius * radius
    }
    
    fun main() {
    	print("Enter radius: ")
    	val radius = readLine()!!.toDouble()
    	println("Circle area: ${circleArea(radius)}")
    }
    ```
    
- 여기서 표준 상수 PI를 썼다. 이 값은 *π*의 근삿값을 표현하며, import 디렉티브를 사용해야 kotlin.math.PI라는 전체 이름이 아니라 PI라는 간단한 이름으로 이 값을 사용할 수 있다.
- 이제 circleArea 함수를 구성하는 요소를 자세히 살펴보자.
    - (함수라는 뜻의 영어 단어 function에서 온) fun 키워드는 컴파일러에게 함수 정의가 뒤따라온다는 사실을 알려준다.
    - 변수 이름과 마찬가지로 아무 식별자나 함수 이름으로 쓸 수 있다(여기서는 circleArea를 썼다).
    - 다음에는 괄호로 둘러싸여 있는 콤마(,)로 분리한 파라미터 목록이 온다. 파라미터 목록은 함수를 호출할 때 넘길 수 잇는 데이터를 컴파일러에게 알려준다.
    - 반환 타입(여기서는 Double)은 함수를 호출한 쪽에 돌려줄 반환값의 타입이다.
    - 함수 본문(body)은 { }로 감싼 블록이며, 함수의 구현을 기술한다.
- 함수가 파라미터를 받지 않는다고 해도 파라미터를 감싸는 괄호는 꼭 있어야 한다는 점에 유의해야 한다. 예를 들면 다음과 같다.
    
    ```kotlin
    fun readInt(): Int {
    	return readLine()!!.toInt()
    }
    
    fun main() {
    	println(readInt())
    }
    ```
    
- 자바와 마찬가지로 함수의 결괏값을 return 문으로 지정한다. return 문은 함수 실행을 끝내고 호출한 쪽에 제어를 돌려준다. return 문 다음에 위치한 코드는 실질적으로 죽어있는 코드이며, 결코 실행되지 않는다.

> **자바 vs 코틀린**  
자바와 달리 코틀린에서 도달할 수 없는 코드(unreachable code)는 오류가 아니다. 하지만 컴파일러는 경고를 표시하고 IDE는 해당 부분을 강조해주기 때문에 코드 중 일부가 죽은 코드임을 쉽게 알 수 있다.
> 
- 자바처럼 코틀린에도 블록 문(block statement)이 있다. 블록 문은 기본적으로 { }로 감싼 문(statement)의 그룹을 말한다. 문은 새줄 문자로 분리하거나(이런 식으로 분리하는 쪽을 권장함) 세미콜론으로 분리하며, 순서대로 실행된다.
- 함수 본문을 작성할 때 우리는 이미 블록을 사용했다. 문법적으로 문장이 하나 들어갈 수 있는 위치에 여러 문장을 넣고 싶다면 언제든 블록을 사용할 수 있다. 예를 들어 루프의 몸통이나 조건문의 각 경우를 나타내는 문장 위치에 블록을 쓸 수 있다. 실제로 루프에서는 몸통이 단 한 문장으로 구성된 경우라도 { }로 둘러싸서 블록으로 코드를 작성하는 경우가 많다.
- 블록 안에는 지역 변수나 지역 함수 정의가 들어갈 수 있다. 이런 선언의 영역(scope)은 해당 함수/변수가 선언된 블록 내부로 제한된다.
- 파라미터 정의는 암시적으로 함수가 호출될 때 자동으로 인자 값으로 초기화되는 지역 변수로 취급된다.

> **자바 vs 코틀린**  
자바 메서드 파라미터는 디폴트가 가변이므로 함수 내부에서 변경하지 못하게 하려면 final을 지정해 불변 값으로 바꿔야 하는데, 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
> 

```kotlin
fun increment(n: Int): Int {
	return n++ // Error: can't change immutable variable
}
```

- 그리고 파라미터 앞에 val이나 var를 표시할 수 없다는 점에 유의해야 한다. 이렇게 강제하는 이유는 파라미터에 대입하는 중에 실수할 가능성이 높을 뿐 아니라 파라미터를 불변 값으로 강제하는 편이 더 깔끔하고 이해하기 편한 코드를 만들어내기 때문이다.
- 코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은, 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다. 특히 호출 인자로 전달한 변수를 변경해도(ex - 앞에서 본 원 넓이 예제의 main 함수 안에 있는 radius) 호출된 함수 내부의 파라미터 값에는 영향이 없다는 뜻이다. 하지만 파라미터가 참조(ex - 배열 타입)라면 호출한 쪽의 데이터는 그대로 남아있고 이 데이터에 대한 참조만 복사된다. 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다. 예를 들어 다음 함수는 정수 배열을 가리키는 (불변) 참조를 받아서 첫 번째 원소를 변경하며, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
    
    ```kotlin
    fun increment(a: IntArray): Int {
    	return ++a[0]
    }
    
    fun main() {
    	val a = intArrayOf(1, 2, 3)
    	println(increment(a)) // 2
    	println(a.contentToString()) // [2, 2, 3]
    }
    ```
    
- 타입 지정을 생략해도 되는 변수와 달리 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서 파라미터 타입을 추론하지 못한다.
- 반면 반환 타입은 함수 파라미터에서 추론이 가능한데도 여전히 명시해야 한다. 함수에서 결괏값을 결정해 외부로 나가는 지점(즉, return으로값을 반환하는 지점)이 여러 곳일 수 있는데 함수 본문의 모든 반환 지점을 살펴보고 반환 타입을 알아내기 어려울 수 있기 때문이다. 이런 면에서 함수 정의에 있는 반환 타입은 일종의 문서화 역할을 하며, 함수 정의의 첫 줄만 보고도 함수가 만들어내는 값이 무엇인지 바로 알 수 있게 해준다.
- 하지만 경우에 따라 반환 타입을 생략할 수 있는데, 이런 예외적인 경우가 두 가지 경우가 있다.
    - 유닛(Unit) 타입을 반환하는 경우
        - 유닛은 자바 void에 해당하는 코틀린 타입으로, 함수가 의미 있는 반환값을 돌려주지 않는다는 뜻이다.
        - 이런 함수가 반환하는 값은 Unit이라는 내장 타입에 속하는 Unit이라는 상수다. 함수 정의에서 반환값 타입을 지정하지 않으면 코틀린은 여러분이 Unit 함수를 정의한다고 가정한다. 즉, 다음 두 함수의 정의는 서로 동등하다.
            
            ```kotlin
            fun prompt(name: String) {
            	println("***** Hello, $name! ****")
            }
            
            fun prompt(name: String): Unit {
            	println("***** Hello, $name! ****")
            }
            ```
            
        - Unit 함수는 결과가 항상 Unit으로 동일하기 때문에 결과를 지정하는 return 문을 쓸 필요가 없다. 하지만 함수 본문의 끝에 도달하기 전에 함수 실행을 마치려면 return 문을 사용해 함수를 끝내야 한다(return Unit이라고 써도 정상적인 문장이지만, 이 경우 Unit은 불필요한 중복일 뿐이다).
        - 식이 본문인(expression-body) 함수어떤 함수가 단일 식으로만 구현될 수 있다면 return 키워드와 블록을 만드는 중괄호({ })를 생략하고 다음과 같은 형태로 함수를 작성해도 된다. 여기서 반환 타입과 함수식 본문 사이에 =가 들어있다는 점에 유의해야 한다.
            
            ```kotlin
            fun circleArea(radius: Double): Double = PI * radius * radius
            ```
            
        - 위와 같은 구문은 = 기호로 변수를 초기화하는 식을 지정했던 변수 정의와 비슷하다. 변수와 마찬가지로 식이 본문인 함수에서도 반환 타입을 생략할 수 있다.
            
            ```kotlin
            fun circleArea(radius: Double) = PI * radius * radius // 반환값이 Double로 추론됨
            ```
            
        - 식이 본문인 함수는 명시적인 반환 타입 정의를 쓰지 않아도 될 정도로 간단하다고 간주된다. 하지만 이 기능은 조심스럽게 사용해야 한다. 복잡하게 표현된 식이 본문인 함수는 일반적인 블록 구문을 사용해 가독성을 높여주는 편이 낫다.
        - 블록이 본문인 함수를 정의할 때 { } 앞에 =를 넣으면 이 블록이 익명 함수를 기술하는 람다로 해석되기 때문에 여러분이 원하는 결과를 얻을 수 없다. 다음 함수를 보자.
            
            ```kotlin
            fun circleArea(radius: Double) = { PI * radius * radius }
            ```
            
        - 위 정의는 미리 정해진 반지름에 해당하는 원의 넓이를 계산해주는 다른 함수를 반환하는 함수 정의에 해당하며, 올바른 정의다. 반면 비슷한 정의에서 블록 안에 return을 추가하면 컴파일 오류가 발생한다.
            
            ```kotlin
            fun circleArea(radius: Double) = {
            	return PI * radius * radius
            	// error: 'return' is not allowed here
            	// error: type mismatch: inferred type is () -> [ERROR : Return not allowed] but Double was expected
            }
            ```
            
        - 이 오류는 타입 불일치로 인해 발생하며, 식이 본문인 함수 안에서 return 문이 금지되기 때문이다(**5장 고급 함수와 함수형 프로그래밍 활용하기**를 참조하면 도움이 될 수 있다).