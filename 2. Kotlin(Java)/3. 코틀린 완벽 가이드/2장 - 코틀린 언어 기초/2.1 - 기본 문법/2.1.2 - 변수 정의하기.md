# 2.1.2 - 변수 정의하기

- 코틀린에서 변수를 정의하는 가장 간단한 형태는 다음과 같다.
    
    ```kotlin
    val timeInSeconds = 15
    ```
    
- 이 정의를 이루는 요소는 아래와 같다.
    - **val 키워드(keyword)**
        - 값을 뜻하는 value에서 유래했다.
    - **변수 식별자(identifier)**
        - 새 변수에 이름을 부여하고, 나중에 이를 가리킬 때 사용한다.
    - **변수의 초깃값(initial value)을 정의하는 식**
        - = 기호 뒤에 온다.

> **자바 vs 코틀린**  
변수 정의 뒤에 세미콜론(;)이 없다. 코틀린에서는 줄 끝에 세미콜론을 생략해도 되며, 실제로 세미콜론을 쓰지 않는 스타일을 더 권장한다. 한 줄에 한 문장만 넣으면 실질적으로 코드에서 세미콜론을 거의 사용하지 않아도 된다.
> 

> **IDE 팁**  
인텔리제이는 불필요한 세미콜론을 경고함으로써 세미콜론을 사용하지 않는 코드 스타일을 권장한다.
> 

- 아래 코드는 사용자에게 정수 두 개를 물어보고 그 두 수의 합을 표시하는 프로그램의 코틀린 코드이다.
    
    ```kotlin
    fun main() {
    	val a = readLine()!!.toInt()
    	val b = readLine()!!.toInt()
    	println(a + b)
    }
    ```
    
- 이 코드가 하는 일을 더 자세히 알아보면,
    - **`readLine()`**은 프로그램에서 readLine을 실행하게 하는 호출 식(call expression)이다. readLine은 표준 입력(standard input)에서 한 줄을 읽어서 문자열로 반환해주는 표준 코틀린 함수다.
    - **`!!`**는 null 아님 단언(not-null assertion)으로, readLine()의 결과가 null일 경우 예외를 발생시킨다. 자바와 달리 코틀린은 어떤 타입이 nullable한지 추적하고, null이 아닌 것이 확실하지 않은 값에 대해 toInt() 함수를 호출하지 못하게 막음으로써 null로 인한 오류를 방지한다. 여기서는 콘솔에서 값을 읽을 경우 readLine()이 null을 반환하지 않을 것이 확실하므로 !!로 null이 될 수 있을 가능성을 무시하게 만든다. **4장 클래스와 객체 다루기**에서 null 가능성을 더 자세히 다룬다.
    - readLine()의 결과에 대해 **`toInt()`** 함수를 호출한다. toInt()는 코틀린 String 클래스가 제공하는 메서드로, 메서드가 호출된 대상 문자열을 정숫값으로 변환한다. 대상 문자열이 올바른 정수값의 형태가 아니라면 toInt()는 런타임 에러를 내면서 프로그램을 종료시킨다. 지금은 모든 사용자 입력이 정상이라 가정하고, 오류 처리는 다음 장까지 미뤄둔다.
    - toInt()를 호출한 결과를 같은 줄에서 정의 중인 **`a`** 변수에 저장한다.
    - 마찬가지로 **`b`**라는 두 번째 변수를 정의하고, 사용자가 입력한 정수를 저장한다.
    - 마지막으로 **`a + b`**로 두 수의 합을 계산한 다음, 결과를 **`println()`** 함수에 전달한다. println()은 인자로 받은 값을 표준 출력에 출력한다.
- 이 코드의 a와 b 변수는 함수 안(이 경우는 main())에서 정의했기 때문에 **지역 변수**라고 한다.
- 이와 별도로 코틀린에서는 **프로퍼티(property)**라는 변수와 비슷한 값을 정의할 수 있다.
    - 값을 그대로 읽거나 쓰는 변수와 달리 프로퍼티에서는 값을 읽거나 쓸 때 계산을 수행할 수 있다.
    - 예를 들어, 앞으로 보겠지만 코틀린의 모든 문자열에는 문자열에 포함된 문자의 개수가 들어있는 `length`라는 프로퍼티가 있다.
- 변수 타입을 지정하지 않았음에도 프로그램이 성공적으로 컴파일되고 실행되는 이유는 **타입 추론**(type inference)이라는 기능 때문이다. 타입 추론은 대부분의 경우 컴파일러가 코드의 문맥에서 타입을 도출해주는 언어 기능이다. 여기서 컴파일러는 toInt() 함수가 Int 타입의 값을 반환한다는 사실을 알고 있으며, 이 결과를 변수에 대입했기 때문에 변수 타입 또한 Int로 추론한다.
    - 타입 추론 덕분에 코틀린은 강한 타입 지정(strongly typed) 언어인 동시에 사용자가 불필요한 타입 정보를 코드에 추가해서 코드가 지저분해지는 일을 막을 수 있다.

> **자바 vs 코틀린**  
자바도 자바 10부터 코틀린과 비슷한 지역 변수 타입 추론을 도입했다.
> 
- 필요할 때는 타입을 명시해도 된다. 타입으르 명시하려면 변수 이름 뒤에 콜론(:)을 표시하고, 그 뒤에 타입을 적는다.
    
    ```kotlin
    val n: Int = 100
    val text: String = "Hello!"
    ```
    
- 이 경우 초깃값이 지정한 타입에 속해야 한다. 다음 코드는 컴파일 오류를 일으킨다.
    
    ```kotlin
    val n: Int = "Hello!" // Error: assigning String value to Int variable
    ```
    

> **IDE 팁**  
인텔리제이에서는 컴파일러가 식이나 값에 대해 추론한 타입을 볼 수 있다. `Ctrl(Cmd) + Shift + P)`를 누르면 된다.
> 

- 초기값을 생략하고 나중에 다른 문에서 변수를 초기화할 수도 있다. 이런 방식은 초깃값을 계산하는 식을 한 줄로 쓸 수 없는 경우에 편리하다. 이 경우 변수 타입을 명시해야 한다.
    
    ```kotlin
    val text: String
    text = "Hello!"
    ```
    
- 하지만 변수 값을 읽기 전에 변수를 초기화해야 한다. 변수 사용 전 변수를 초기화했는지 컴파일러가 확실히 알 수 없는 경우 컴파일 오류가 발생한다.
    
    ```kotlin
    val n: Int
    println(n + 1) // Error: variable n is not initialized
    ```