# 2.2.7 - 불 타입과 논리 연산

- 코틀린은 참(true)나 거짓(false) 중 하나로 판명되는 불(Boolean) 타입과 논리 연산을 제공한다.
    
    ```kotlin
    val hasErrors = false
    val testPassed = true
    ```
    
- 자바와 마찬가지로 코틀린 Boolean도 수 타입과는 다른 타입이며, 암시적으로든 toInt() 등의 명시적인 내장 연산을 써서든 수로 변환할 수 없다(반대로 수를 Boolean 타입으로 변환할 수도 없다). 개발자는 비교 연산자나 조건식(if나 when 등)을 사용해 불이 아닌 값에서 불 값을 만들어야 한다.
- 불이 지원하는 연산은 다음과 같다.
    - ! - 논리 부정
    - or, and, xor - 즉시 계산(eager) 방식의 논리합, 논리곱, 논리배타합
    - ||, && - 지연 계산(lazy) 방식의 논리합, 논리곱
- 지연 계산 연산자(||, &&)는 자바의 동일 연산자와 똑같은 의미를 제공한다. ||의 왼쪽 피연산자가 참이면 오른쪽 피연산자를 계산하지 않는다. &&의 왼쪽 피연산자가 거짓이면 오른쪽 피연산자를 계산하지 않는다. 이런 방식의 계산은 왼쪽 피연산자에 부수 효과가 포함된 경우 유용할 수 있다.

> **자바 vs 코틀린**  
자바와 달리 코틀린은 &와 | 연산자를 제공하지 않는다. and와 or가 각각 &와 |를 대신한다.
> 
- 동등성/비동등성 연산자 ==와 !=를 사용한 예를 살펴보자(이 두 연산자는 **다음 절**에서 자세히 다룬다).
    
    ```kotlin
    println((x == 1) or (y == 1)) // true
    println((x == 0) || (y == 0)) // false
    println((x == 1) and (y != 1)) // true
    println((x == 1) and (y == 1)) // false
    println((x == 1) xor (y == 1)) // true
    println((x == 1) xor (y != 1)) // false
    println(x == 1 || y / (x - 1) != 1) // false
    println(x != 1 && y / (x - 1) != 1) // false
    ```
    
- 마지막 두 예에서는 지연 계산이 필수적인데, x == 1일 때 오른쪽 연산을 계산하면 0으로 나누는 오류가 발생하기 때문이다.
- 지연 계산과 즉시 계산 방식에서 논리곱과 논리합의 차이를 기억해야 한다. 즉시 계산인 and, or, xor은 이름 붙은 중위 연산자와 같은 우선순위이므로 && 연산이나 || 연산보다 더 우선해 계산된다. 예를 들면,  
`a || b and c or d && e`  
위 식은 다음과 같이 계산된다.  
`a || (((b and c) or d) && e)`