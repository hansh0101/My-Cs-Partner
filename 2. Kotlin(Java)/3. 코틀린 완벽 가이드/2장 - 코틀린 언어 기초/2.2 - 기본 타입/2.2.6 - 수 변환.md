# 2.2.6 - 수 변환

- 각 수 타입마다 값을 다른 수 타입으로 변환하는 연산이 정의되어 있다. 각 연산은 변환하려는 목적 타입을 알기 쉬운 이름으로 되어 있다. 예를 들어 toByte(), toShort(), toInt(), toLong(), toFloat(), toDouble(), toChar() 등이다. Char 값에 대해서도 같은 범위의 연산을 제공한다.

> **자바 vs 코틀린**  
자바와 달리 코틀린에서는 범위가 큰 타입이 사용돼야 하는 문맥에 범위가 작은 타입을 쓸 수 없다. 예를 들어 Int 값을 Long 변수에 대입할 수 없다. 다음 코드는 컴파일 오류를 발생시킨다.
> 

```kotlin
val n = 100 // Int
val l: Long = n // Error: can’t assign Int to Long
```

- 이렇게 하게 된 이유는 앞에서 언급한 암시적인 박싱 때문이다. 일반적인 Int 값(또는 다른 수 타입의 값)이 꼭 원시 타입의 값으로 표현된다는 보장이 없다. 따라서 방금 본 코드와 같은 더 큰 범위의 타입으로 변환하는 경우 다른 박싱한 타입의 값을 만들어낼 수 없는 가능성이 생기고, 이로 인해 동등성(equality) 요구 조건을 만족시키지 못하게 되면서 미묘한 오류를 발생시킬 수 있다. 위 코드를 올바른 코드로 인정하면 다음 연산이 false를 출력할 것이다.
    
    ```kotlin
    println(l == n)
    ```
    
- 하지만 이런 결과를 프로그래머가 예상하기는 힘들다. 자바에서도 박싱한 타입과 관련해 비슷한 문제가 있다.
    
    ```java
    // 자바 코드
    Integer n = 100;
    Long l = n; // Error: can't assign Integer to Long
    ```
    
- 정수 타입 사이의 변환은 대상 타입이 더 큰 범위를 담는 타입인 경우 손실 없이 수행된다. 그렇지 않은 경우 MSB(2진수로 표현했을 때 상위 비트 쪽)를 잘라내고 나머지를 대상 타입의 값으로 변환한다. Char 타입을 다른 타입의 값으로 바꾸거나 다른 타입의 값을 Char 타입으로 바꾸는 경우도 그렇다.
    
    ```kotlin
    val n = 945
    println(n.toByte()) // -79
    println(n.toShort()) // 945
    println(n.toChar()) // α
    println(n.toLong()) // 945
    ```
    
- 부동소수점 수 타입과 관련된 변환의 경우, 일반적으로 대상 타입과 무관하게 정밀도를 잃을 수 있다. 예를 들어 Long을 Float로 변환하면 LSB 쪽(2진수로 표현했을 때 하위 비트 쪽)을 잃어버릴 수 있다. 부동소수점 수를 정수로 변환하는 연산은 기본적으로 0쪽으로 어림(rounding to zero)하는 연산이다.
    
    ```kotlin
    println(2.5.toInt()) // 2
    println(-2.5).toInt()) // -2
    println(1_000_000_000_000.toFloat().toLong()) // 999999995904
    ```