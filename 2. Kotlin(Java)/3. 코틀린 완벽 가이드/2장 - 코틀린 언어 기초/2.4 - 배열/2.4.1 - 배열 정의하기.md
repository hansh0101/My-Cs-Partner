# 2.4.1 - 배열 정의하기

- 배열 구조를 구현하는 가장 일반적인 코틀린 타입은 Array<T>이다. 여기서 T는 원소의 타입을 뜻한다.
- 만들려는 배열의 크기를 미리 알 수 있다면 표준 함수 중 하나를 사용해 배열을 생성할 수 있다.
    
    ```kotlin
    val a = emptyARray<String>()
    val b = arrayOf("hello", "world")
    val c = arrayOf(1, 4, 9)
    ```
    
- 각 함수는 제네릭(generic)이다. 이 말은 호출할 때 원소의 타입을 지정해 줘야 한다는 뜻이다.
- 하지만 타입 추론 덕분에 두 번째와 세 번째 함수 호출의 타입을 인자들의 타입에서 알아낼 수 있다.
    - 예를 들어 정수로 배열을 만들면 이 배열은 분명 Array<Int> 타입일 것이다.
    - 하지만 첫 번재 호출에서는 컴파일러가 타입을 추론할 수 있는 단초가 없다. 따라서 꺽쇠(< >) 사이에 원소 타입을 명시해야 한다.
    - 제네릭 타입에 대한 자세한 내용은 **9장 제네릭스**를 참고하길 바란다.
- 인덱스로부터 원소를 만들어내는 방법을 기술해 배열을 생성하는 더 유연한 방법도 있다. 다음 코드는 1부터 사용자가 입력한 값에 이르는 정수의 제곱으로 이뤄진 배열을 만든다.
    
    ```kotlin
    val size = readLine()!!.toInt()
    val squares = Array(size) { (it + 1) * (it + 1) }
    ```
    
- 중괄호({ }) 안에 들어있는 언어 요소를 람다(lambda)라고 부른다. 람다는 인덱스를 기반으로 값을 계산하는 식을 정의한다. 이 때 인덱스를 표현하는 변수로 자동으로 선언되는 it을 사용한다. 배열 인덱스는 0부터 (배열 크기 - 1)이기 때문에 이 배열에서는 1, 4, 9 등의 값이 들어간다.
    - 람다에 대한 자세한 내용은 **5장 고급 함수와 함수형 프로그래밍 활용하기**를 참고하길 바란다.
- Array<Int>를 사용하는 배열은 제대로 작동하지만 모든 수를 박싱하기 때문에 그다지 실용적이지 못한 해법이다. 이런 이유로 코틀린은 더 효율적인 ByteArray, ShortArray, IntArray, LongArray, FloatArray, DoubleArray, CharArray, BooleanArray라는 특화된 배열 타입을 제공한다. JVM에서 이런 배열 타입들은 int[], boolean[] 등의 원새 타입 배열로 표현된다. 이런 특화된 배열에도 arrayOf()나 Array()에 해당하는 함수가 함께 따라온다.
    
    ```kotlin
    val operaions = charArrayOf('+', '-', '*', '/', '%')
    val squares = IntArray(10) { (it + 1) * (it + 1) }
    ```
    

> **자바 vs 코틀린**  
자바와 달리 코틀린에는 new 연산자가 없기 때문에 배열 인스턴스 생성이 일반 함수 호출처럼 보인다. 코틀린에서는 배열 원소를 명시적으로 초기화해야 한다는 점에도 유의해야 한다.
>